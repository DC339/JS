<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>RegExp</title>
</head>
<body>
	<script>
		var str = " abc bcddbchj i";
		//正则化-----定位符
		//以字符串开始或结束的位置进行匹配（^、$）
		//以开始的位置匹配，匹配任何以空格+单词开始的字符串，返回第二个子模式匹配的内容
        function findNthWord(str, n) {
            var re = new RegExp("^(\\s*(\\w+)){" + n +"}");
            re.test(str);
            return RegExp.$2;
        }
        //匹配以空格加字符串结尾的字符串，返回第一个子模式匹配的内容
		function findLastNthWord(str, n) {
			var re = new RegExp("\\s*(\\w+)(\\s*(\\w+)){" + (n-1) +"}$");
			re.test(str);
			return RegExp.$1;
		}
        //以单词边界匹配全局中以非空字符串开头非空字符串结尾的最短字符串（非贪婪模式）
        function findNthWord2(str, n) {
        	var re = /\b(\S+?)\b/g;
        	var arr = str.match(re);
        	if(arr.length >= n) 
        		return arr[n-1];
        	else
        		return null;
        }
        function findLastNthWord2(str, n) {
        	var re = /\b(\S+?)\b/g;
        	var arr = str.match(re);
        	if(arr.length >= n) 
        		return arr[arr.length - n];
        	else
        		return null;
        }
		console.log(findNthWord2(str, 1));
		console.log(findLastNthWord2(str, 1));

		//选择和分组
		 var s1 = "010-62771234";
		 // var re = /(010|021)-\d{8}/; //捕获性分组
		 // var re = /(?:(010|021))-\d{8}/;  //非捕获性分组
		 var re = /(010|021)-(\d{4})(?:1234)/;  //使用前瞻元字符分组，正则表达式运算器在匹配时可以提前查看一些字符，而不移动当前的匹配位置。
		 re.test(s1);
		 alert(RegExp.$2);
		
	</script>
</body>
</html>
